#version 430 core

struct AttribData{		// 顶点属性数据
	vec3 position;
	vec3 normal;
	// vec4 color;
};

layout (local_size_x=1, local_size_y=1, local_size_z=1) in;		// 输入的工作组信息

layout (std140, binding = 0) buffer destBuffer{						// 与VBO进行绑定的缓冲区
	AttribData data[];
}

// 假设一个m*n的网格，在主程序中glDispatchCompute(m,n,1)，每个顶点是一个invocation
// 每个invocation计算出其中一个顶点的位置，然后写入到destBuffer中
// 假设网格是先y后x的顺序

uniform LeafInfo{
	float height;
	float width;

	float k;
	float theta;
	float SLAngle;
	float MVAngle;
}

float wFunc(float h) {  // 生成叶片宽度关于长度的函数
	return (-1.0f / powf(height, 2) * powf(h, 2) + 2 * theta / height * h + (1 - 2 * theta)) * width / powf(1 - theta, 2);
}

vec3 rotateAlongAxis(vec3 position, float angle, vec3 axis){
	// from https://zhuanlan.zhihu.com/p/56587491 
	float c = cos(angle), s = sin(angle);		// actually radians
	float xx = axis.x * axis.x, yy = axis.y * axis.y, zz = axis.z * axis.z;
	float xy = axis.x * axis.y, xz = axis.x *axis.z, yz = axis.y * axis.z;
	mat3 T = mat3(
		xx * (1-c) + c			,  xy*(1-c) +axis.z*s	,	xz*(1-c)-axis.y * s	,
		xy*(1-c)-axis.z*s		, yy*(1-c) +c				,	yz*(1-c)+axis.x * s	,
		xz*(1-c)+axis.y * s	, yz*(1-c)-axis.x * s	,	zz*(1-c)+c
	);
	return T * position;
}

void main(){
	uint xi = gl_GlobalInvocationID.x;
	uint yi = gl_GlobalInvocationID.y;
	uint index = xi*n + yi;
	
	//float xt = xi / (gl_GlobalWorkGroups.x - 1.0f);	// 长轴方向的分位点
	//float yt = yi / (gl_GlobalWorkGroups.y - 1.0f);	// 宽轴方向的分位点

	float a = -k * width / height, b = tanf(PI / 2.0f - SLAngle * PI / 180.0f);
	float ds = height / (gl_GlobalWorkGroups.x - 1.0f);
	float tmp, frac, costheta, sintheta;

	float x = 0.0f, y = 0.0f, z = 0.0f;

	for(uint i=0; i<gl_WorkGroupID.x; i++){			// i 会从0开始到m-1, 在长轴方向上有m个顶点，分割了m-1段
		tmp = 2 * a * x + b;
		frac = sqrtf(1.0f + tmp*tmp);
		costheta = 1.0f / frac;
		sintheta = tmp / frac;
		x += ds * costheta;
		y += ds * sintheta;
	}
	z = (gl_WorkGroupID.y - glGlobalWorkGroups.y/2.0f) / (glGlobalWorkGroups.y/2.0f)*wFunc(x);		// 叶片宽度z和
	// 此时已经计算出了x y z，下面进行一个主叶脉旋转(仿射变换)
	vec3 new_position = rotateAlongAxis(vec3(x,y,z), MVAngle * PI / 180.0f, vec3(costheta, sintheta, 0.0f));
	data[index].position.x = new_position.x;
	data[index].position.y = new_position.y;
	data[index].position.z = new_position.z;
}
